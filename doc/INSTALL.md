<!-- markdownlint-disable MD034 -->
INSTALL.md (with Docker)
===

Table of Content
---

<!-- TOC -->

- [Express set-up](#express-set-up)
    - [0. Pre-requisite](#0-pre-requisite)
    - [1. initialize a fresh .env file](#1-initialize-a-fresh-env-file)
    - [2. Setup containers and DB](#2-setup-containers-and-db)
    - [3. static files](#3-static-files)
- [Development environment](#development-environment)
- [A few words on config](#a-few-words-on-config)
    - [Production](#production)
    - [Development](#development)

<!-- /TOC -->

## Express set-up

### 0. Pre-requisite

- git repo checked out (`git clone git@github.com:ebreton/djangobootstrap.git`)
- sudo gem install github_changelog_generator in order to generate automatically the CHANGELOG file

### 1. initialize a fresh .env file

    make init-venv

You might want to change the default values for the following vars:

- DJANGO_SETTINGS_MODULE=settings.dev
- SITE_URL=https://your-host.epfl.ch
- SERVER_HOST=your-host
- ALLOWED_HOSTS=your-host,other-host,yet-another
- DEV_PORT=443

You can check what values will be taken into account with

    $ make vars
    App-related vars:
      SECRET_KEY="SeLKDmig0mYF04WVkpZ6mowJ1FiodYkC0C4ZV6Rkuvc="
      DJANGO_SETTINGS_MODULE=settings.dev
      SITE_URL=https://your-host.epfl.ch
      SERVER_HOST=your-host
      ALLOWED_HOSTS=your-host,other-host,yet-another
    ...

The `SECRET_KEY` has been generated by the make `init-venv` command

### 2. Setup containers and DB

    make reset

The command will build the image, run the containers and initialize the DB

### 3. static files

The static files are loaded with the image (as well as the src files), but when developing, those folders are overriden with your local ones. You therefore need to generate the staticfiles on your computer to get the proper look and feel...

    make collectstatic

## Development environment

Warning if you are an EPFL developer, running your developement environment on Ubuntu, with VPN activated, check your VPN connexion is not blocked par your docker ::

    sudo iptables -L

If ciscovpn services are inside "Chain FORWAR (policy DROP)", you should ::

    sudo iptables -F ciscovpn

The first thing to do is enable a post-commit git hook in order to have the versions taken care of

    cp update_release.py .git/hooks/post-commit

Just make sure that your python executable is aligned with the one declared in the hook:

    $ which python
    /usr/bin/python

    # if your path is different, change it in the first line of the post-commit file
    $ vi .git/hooks/post-commit
    ...

The script depends on the existence of (at least) one git tag. If you have none, you should run

    git tag 0.1.0
    git push --tags

The hook will run the following on each commit:

    $ python update_release.py
    INFO - compute - will set _version=0.1.1-rc
    INFO - compute - will set _build=34xxx
    INFO - compute - will set _release=0.1.0-1-g34xxx

You can access, with the default configuration :

- the app itself
  - any gaspar credential
  - https://127.0.0.1:8000/
- its admin
  - with the service account *infoscience-exports*
  - or with a gaspar account which has received admin rights
  - https://127.0.0.1:8000/admin

To release a new version (i.e version, branch, tag, github release)

    make release

To deploy a new version of your code (without losing data)

    make deploy

To rebuild everything from scratch

    make reset

To run the tests

    make test

Or to test more intensively with nose and coverage

    make coverage

To check your environment variables

    # on your host
    $ make vars

    # inside the web container
    $ docker-compose -f docker-compose-dev.yml run web env

## A few words on config

Three docker images will be pulled / build on the following command. Those docker images are the same for all environments.

### Production

Files are copied inside the images for production purpose.

- the code of the application: ./infoscience_exports
- the generated static files:  ./staticfiles

Once the images built, just run the containers with

    docker-compose up

If you want to run the containers as a daemon, use the -d option. Logs are still available on demand

    docker-compose up -d
    docker-compose logs

### Development

For development purpose, those files can also be mounted with local tree structure

    docker-compose -f docker-compose-dev.yml up

You will thus be allowed to get change on the fly :

- the code of the application: ./infoscience_exports
- the generated static files:  ./staticfiles
- some assets you might need:  ./nginx/assets
- the nginx configuration:     ./nginx/sites-enabled/web.conf

Aside from the volumes, docker-compose-dev.yml  also makes use of

- .env to load environment variables
- settings/dev.py to set django settings

Would you need to connect directly to the DB, we exposed an access to the host on port 25432

    psql -h 127.0.0.1 -p 25432 -U django -W infoscience_exports
